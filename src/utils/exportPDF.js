import jsPDF from 'jspdf';
import { getPathwayDescription, formatDuration } from './pathwayGenerator';

/**
 * Export roadmap as PDF
 */
export async function exportRoadmapPDF(roadmap) {
  const { pathway, pathwayName, phases, summary, answers } = roadmap;
  const pathwayInfo = getPathwayDescription(pathway);

  // Create PDF document
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4',
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  let yPos = margin;

  // Helper function to check if we need a new page
  const checkNewPage = (neededSpace) => {
    if (yPos + neededSpace > pageHeight - margin) {
      doc.addPage();
      yPos = margin;
      return true;
    }
    return false;
  };

  // Header
  doc.setFillColor(15, 23, 42); // slate-900
  doc.rect(0, 0, pageWidth, 50, 'F');

  doc.setTextColor(255, 255, 255);
  doc.setFontSize(24);
  doc.setFont('helvetica', 'bold');
  doc.text('Your Learning Roadmap', margin, 25);

  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  // Don't use emojis - jsPDF doesn't support them in default fonts
  doc.text(`${pathwayName} - ${pathwayInfo.tagline}`, margin, 35);

  yPos = 60;

  // Summary Box
  doc.setFillColor(241, 245, 249); // slate-100
  doc.roundedRect(margin, yPos, pageWidth - 2 * margin, 30, 3, 3, 'F');

  doc.setTextColor(51, 65, 85); // slate-700
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');

  const boxY = yPos + 12;
  const boxWidth = (pageWidth - 2 * margin) / 4;

  doc.text(`${summary.totalCourses}`, margin + boxWidth * 0.5, boxY, { align: 'center' });
  doc.text(`${summary.totalHours}`, margin + boxWidth * 1.5, boxY, { align: 'center' });
  doc.text(`${formatDuration(summary.totalWeeks)}`, margin + boxWidth * 2.5, boxY, { align: 'center' });
  doc.text(`${summary.weeklyHours} hrs/wk`, margin + boxWidth * 3.5, boxY, { align: 'center' });

  doc.setFontSize(8);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100, 116, 139); // slate-500
  doc.text('Courses', margin + boxWidth * 0.5, boxY + 8, { align: 'center' });
  doc.text('Total Hours', margin + boxWidth * 1.5, boxY + 8, { align: 'center' });
  doc.text('Duration', margin + boxWidth * 2.5, boxY + 8, { align: 'center' });
  doc.text('Weekly Pace', margin + boxWidth * 3.5, boxY + 8, { align: 'center' });

  yPos += 45;

  // Phases
  phases.forEach((phase, phaseIndex) => {
    checkNewPage(20);

    // Phase header
    doc.setFillColor(59, 130, 246); // blue-500
    doc.roundedRect(margin, yPos, pageWidth - 2 * margin, 12, 2, 2, 'F');

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.text(`${phaseIndex + 1}. ${phase.phaseName}`, margin + 5, yPos + 8);

    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    const courseCount = phase.courses.length;
    const courseWord = courseCount === 1 ? 'course' : 'courses';
    const weekStart = phase.startWeek + 1;
    const weekEnd = phase.endWeek;
    const weekRange = weekStart === weekEnd ? `Week ${weekStart}` : `Week ${weekStart}-${weekEnd}`;
    const phaseInfo = `${courseCount} ${courseWord} â€¢ ${weekRange}`;
    doc.text(phaseInfo, pageWidth - margin - 5, yPos + 8, { align: 'right' });

    yPos += 16;

    // Courses in phase
    phase.courses.forEach((course, courseIndex) => {
      checkNewPage(12);

      // Alternating row background
      if (courseIndex % 2 === 0) {
        doc.setFillColor(248, 250, 252); // slate-50
        doc.rect(margin, yPos - 3, pageWidth - 2 * margin, 10, 'F');
      }

      doc.setTextColor(30, 41, 59); // slate-800
      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');

      // Course number
      doc.setTextColor(100, 116, 139);
      doc.text(`${courseIndex + 1}.`, margin + 3, yPos + 3);

      // Course title (truncate at 62 chars to fit A4 width)
      doc.setTextColor(30, 41, 59);
      const title = course.title.length > 62 ? course.title.substring(0, 59) + '...' : course.title;
      doc.text(title, margin + 12, yPos + 3);

      // Hours
      doc.setTextColor(100, 116, 139);
      doc.text(`${course.estimated_hours || 3}h`, pageWidth - margin - 5, yPos + 3, { align: 'right' });

      yPos += 8;
    });

    // Milestone
    if (phase.milestone) {
      checkNewPage(10);
      doc.setTextColor(59, 130, 246);
      doc.setFontSize(8);
      doc.setFont('helvetica', 'bolditalic');
      doc.text(`>> ${phase.milestone}`, margin + 12, yPos + 3);
      yPos += 8;
    }

    yPos += 8;
  });

  // Footer on last page
  const footerY = pageHeight - 15;
  doc.setTextColor(148, 163, 184); // slate-400
  doc.setFontSize(8);
  doc.setFont('helvetica', 'normal');
  doc.text(
    'Generated by DeepLearning.AI Learning Roadmap Generator | deeplearning.ai',
    pageWidth / 2,
    footerY,
    { align: 'center' }
  );
  doc.text(
    `Generated on ${new Date().toLocaleDateString()}`,
    pageWidth / 2,
    footerY + 5,
    { align: 'center' }
  );

  // Save the PDF
  doc.save(`DLAI-Roadmap-${pathwayName.replace(/\s+/g, '-')}.pdf`);
}

/**
 * Generate shareable URL with encoded answers
 */
export function generateShareableURL(answers) {
  const encoded = btoa(JSON.stringify(answers));
  const baseUrl = window.location.origin + window.location.pathname;
  return `${baseUrl}?pathway=${encoded}`;
}

/**
 * Validate and sanitize decoded answers object
 */
function validateAnswers(obj) {
  if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return null;

  // Prevent prototype pollution - check for OWN properties only
  if (Object.hasOwn(obj, '__proto__') || Object.hasOwn(obj, 'constructor') || Object.hasOwn(obj, 'prototype')) {
    return null;
  }

  const allowedKeys = ['experience', 'goal', 'timeCommitment', 'targetRole',
                       'mathBackground', 'timeline', 'priorCourses', 'interests'];
  const validValues = {
    experience: ['none', 'some-python', 'ml-basics', 'professional'],
    goal: ['career-switch', 'upskill', 'research', 'curiosity'],
    timeCommitment: ['2-5', '5-10', '10-20', '20+'],
    targetRole: ['builder', 'researcher', 'enterprise', 'undecided'],
    mathBackground: ['minimal', 'moderate', 'strong', 'expert'],
    timeline: ['3-months', '6-months', '12-months', 'no-rush'],
  };

  const validated = {};
  for (const key of allowedKeys) {
    if (key in obj) {
      if (key === 'priorCourses' || key === 'interests') {
        if (Array.isArray(obj[key])) {
          validated[key] = obj[key]
            .filter(v => typeof v === 'string' && v.length < 100)
            .slice(0, 50);
        }
      } else if (validValues[key] && validValues[key].includes(obj[key])) {
        validated[key] = obj[key];
      }
    }
  }
  return Object.keys(validated).length > 0 ? validated : null;
}

/**
 * Decode answers from URL
 */
export function decodePathwayFromURL() {
  const params = new URLSearchParams(window.location.search);
  const encoded = params.get('pathway');
  if (encoded) {
    try {
      const decoded = JSON.parse(atob(encoded));
      return validateAnswers(decoded);
    } catch (e) {
      console.error('Failed to decode pathway from URL', e);
      return null;
    }
  }
  return null;
}
